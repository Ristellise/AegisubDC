; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28805.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	adler32_combine
PUBLIC	adler32
PUBLIC	adler32_z
EXTRN	__chkstk:PROC
EXTRN	memchr:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$adler32_combine_ DD imagerel adler32_combine_
	DD	imagerel adler32_combine_+216
	DD	imagerel $unwind$adler32_combine_
;	COMDAT xdata
xdata	SEGMENT
$unwind$adler32_combine_ DD 020501H
	DD	013405H
xdata	ENDS
; Function compile flags: /Ogtpy
; File D:\Aegisub-WangQR\vendor\exten\zlib\adler32.c
;	COMDAT adler32_z
_TEXT	SEGMENT
adler$ = 8
buf$ = 16
len$ = 24
adler32_z PROC						; COMDAT

; 68   :     unsigned long sum2;
; 69   :     unsigned n;
; 70   : 
; 71   :     /* split Adler-32 into component sums */
; 72   :     sum2 = (adler >> 16) & 0xffff;

  00000	44 8b c9	 mov	 r9d, ecx
  00003	4c 8b d2	 mov	 r10, rdx
  00006	41 c1 e9 10	 shr	 r9d, 16

; 73   :     adler &= 0xffff;

  0000a	0f b7 c9	 movzx	 ecx, cx

; 74   : 
; 75   :     /* in case user likes doing a byte at a time, keep it fast */
; 76   :     if (len == 1) {

  0000d	49 83 f8 01	 cmp	 r8, 1
  00011	75 31		 jne	 SHORT $LN13@adler32_z

; 77   :         adler += buf[0];

  00013	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  00016	03 d1		 add	 edx, ecx

; 78   :         if (adler >= BASE)
; 79   :             adler -= BASE;
; 80   :         sum2 += adler;

  00018	81 fa f1 ff 00
	00		 cmp	 edx, 65521		; 0000fff1H
  0001e	44 8d 82 0f 00
	ff ff		 lea	 r8d, DWORD PTR [rdx-65521]
  00025	44 0f 42 c2	 cmovb	 r8d, edx
  00029	43 8d 04 08	 lea	 eax, DWORD PTR [r8+r9]

; 81   :         if (sum2 >= BASE)
; 82   :             sum2 -= BASE;
; 83   :         return adler | (sum2 << 16);

  0002d	3d f1 ff 00 00	 cmp	 eax, 65521		; 0000fff1H
  00032	8d 88 0f 00 ff
	ff		 lea	 ecx, DWORD PTR [rax-65521]
  00038	0f 42 c8	 cmovb	 ecx, eax
  0003b	c1 e1 10	 shl	 ecx, 16
  0003e	41 0b c8	 or	 ecx, r8d
  00041	8b c1		 mov	 eax, ecx

; 131  : }

  00043	c3		 ret	 0
$LN13@adler32_z:

; 84   :     }
; 85   : 
; 86   :     /* initial Adler-32 value (deferred check for len == 1 speed) */
; 87   :     if (buf == Z_NULL)

  00044	48 85 d2	 test	 rdx, rdx
  00047	75 04		 jne	 SHORT $LN16@adler32_z

; 88   :         return 1L;

  00049	8d 42 01	 lea	 eax, QWORD PTR [rdx+1]

; 131  : }

  0004c	c3		 ret	 0
$LN16@adler32_z:

; 89   : 
; 90   :     /* in case short lengths are provided, keep it somewhat fast */
; 91   :     if (len < 16) {

  0004d	49 83 f8 10	 cmp	 r8, 16
  00051	73 49		 jae	 SHORT $LN22@adler32_z

; 92   :         while (len--) {

  00053	4d 85 c0	 test	 r8, r8
  00056	74 1b		 je	 SHORT $LN26@adler32_z
  00058	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL2@adler32_z:

; 93   :             adler += *buf++;

  00060	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00064	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]
  00068	03 c8		 add	 ecx, eax

; 94   :             sum2 += adler;

  0006a	44 03 c9	 add	 r9d, ecx
  0006d	49 83 e8 01	 sub	 r8, 1
  00071	75 ed		 jne	 SHORT $LL2@adler32_z
$LN26@adler32_z:

; 95   :         }
; 96   :         if (adler >= BASE)
; 97   :             adler -= BASE;
; 98   :         MOD28(sum2);            /* only added so many BASE's */

  00073	81 f9 f1 ff 00
	00		 cmp	 ecx, 65521		; 0000fff1H
  00079	44 8d 81 0f 00
	ff ff		 lea	 r8d, DWORD PTR [rcx-65521]
  00080	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00085	44 0f 42 c1	 cmovb	 r8d, ecx
  00089	41 f7 e1	 mul	 r9d
  0008c	c1 ea 0f	 shr	 edx, 15
  0008f	6b c2 0f	 imul	 eax, edx, 15

; 99   :         return adler | (sum2 << 16);

  00092	41 03 c1	 add	 eax, r9d
  00095	c1 e0 10	 shl	 eax, 16
  00098	41 0b c0	 or	 eax, r8d

; 131  : }

  0009b	c3		 ret	 0
$LN22@adler32_z:

; 100  :     }
; 101  : 
; 102  :     /* do length NMAX blocks -- requires just one modulo operation */
; 103  :     while (len >= NMAX) {

  0009c	49 81 f8 b0 15
	00 00		 cmp	 r8, 5552		; 000015b0H
  000a3	0f 82 26 01 00
	00		 jb	 $LN45@adler32_z
  000a9	4d 8b d8	 mov	 r11, r8
  000ac	48 b8 f7 b6 98
	63 bb a6 ba 79	 mov	 rax, 8771506548017510135 ; 79baa6bb6398b6f7H
  000b6	49 f7 e0	 mul	 r8
  000b9	4c 2b da	 sub	 r11, rdx
  000bc	49 d1 eb	 shr	 r11, 1
  000bf	4c 03 da	 add	 r11, rdx
  000c2	49 c1 eb 0c	 shr	 r11, 12
  000c6	49 69 c3 50 ea
	ff ff		 imul	 rax, r11, -5552		; ffffffffffffea50H
  000cd	4c 03 c0	 add	 r8, rax
$LL4@adler32_z:

; 104  :         len -= NMAX;
; 105  :         n = NMAX / 16;          /* NMAX is divisible by 16 */

  000d0	ba 5b 01 00 00	 mov	 edx, 347		; 0000015bH
  000d5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL8@adler32_z:

; 106  :         do {
; 107  :             DO16(buf);          /* 16 sums unrolled */

  000e0	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  000e4	03 c8		 add	 ecx, eax
  000e6	41 0f b6 42 01	 movzx	 eax, BYTE PTR [r10+1]
  000eb	44 03 c9	 add	 r9d, ecx
  000ee	03 c8		 add	 ecx, eax
  000f0	41 0f b6 42 02	 movzx	 eax, BYTE PTR [r10+2]
  000f5	44 03 c9	 add	 r9d, ecx
  000f8	03 c8		 add	 ecx, eax
  000fa	41 0f b6 42 03	 movzx	 eax, BYTE PTR [r10+3]
  000ff	44 03 c9	 add	 r9d, ecx
  00102	03 c8		 add	 ecx, eax
  00104	41 0f b6 42 04	 movzx	 eax, BYTE PTR [r10+4]
  00109	44 03 c9	 add	 r9d, ecx
  0010c	03 c8		 add	 ecx, eax
  0010e	41 0f b6 42 05	 movzx	 eax, BYTE PTR [r10+5]
  00113	44 03 c9	 add	 r9d, ecx
  00116	03 c8		 add	 ecx, eax
  00118	41 0f b6 42 06	 movzx	 eax, BYTE PTR [r10+6]
  0011d	44 03 c9	 add	 r9d, ecx
  00120	03 c8		 add	 ecx, eax
  00122	41 0f b6 42 07	 movzx	 eax, BYTE PTR [r10+7]
  00127	44 03 c9	 add	 r9d, ecx
  0012a	03 c8		 add	 ecx, eax
  0012c	41 0f b6 42 08	 movzx	 eax, BYTE PTR [r10+8]
  00131	44 03 c9	 add	 r9d, ecx
  00134	03 c8		 add	 ecx, eax
  00136	41 0f b6 42 09	 movzx	 eax, BYTE PTR [r10+9]
  0013b	44 03 c9	 add	 r9d, ecx
  0013e	03 c8		 add	 ecx, eax
  00140	41 0f b6 42 0a	 movzx	 eax, BYTE PTR [r10+10]
  00145	44 03 c9	 add	 r9d, ecx
  00148	03 c8		 add	 ecx, eax
  0014a	41 0f b6 42 0b	 movzx	 eax, BYTE PTR [r10+11]
  0014f	44 03 c9	 add	 r9d, ecx
  00152	03 c8		 add	 ecx, eax
  00154	41 0f b6 42 0c	 movzx	 eax, BYTE PTR [r10+12]
  00159	44 03 c9	 add	 r9d, ecx
  0015c	03 c8		 add	 ecx, eax
  0015e	41 0f b6 42 0d	 movzx	 eax, BYTE PTR [r10+13]
  00163	44 03 c9	 add	 r9d, ecx
  00166	03 c8		 add	 ecx, eax
  00168	41 0f b6 42 0e	 movzx	 eax, BYTE PTR [r10+14]
  0016d	44 03 c9	 add	 r9d, ecx
  00170	03 c8		 add	 ecx, eax
  00172	41 0f b6 42 0f	 movzx	 eax, BYTE PTR [r10+15]
  00177	44 03 c9	 add	 r9d, ecx

; 108  :             buf += 16;

  0017a	49 83 c2 10	 add	 r10, 16
  0017e	03 c8		 add	 ecx, eax
  00180	44 03 c9	 add	 r9d, ecx

; 109  :         } while (--n);

  00183	83 c2 ff	 add	 edx, -1			; ffffffffH
  00186	0f 85 54 ff ff
	ff		 jne	 $LL8@adler32_z

; 110  :         MOD(adler);

  0018c	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00191	f7 e1		 mul	 ecx
  00193	c1 ea 0f	 shr	 edx, 15
  00196	69 c2 0f 00 ff
	ff		 imul	 eax, edx, -65521	; ffff000fH
  0019c	03 c8		 add	 ecx, eax

; 111  :         MOD(sum2);

  0019e	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  001a3	41 f7 e1	 mul	 r9d
  001a6	c1 ea 0f	 shr	 edx, 15
  001a9	69 c2 0f 00 ff
	ff		 imul	 eax, edx, -65521	; ffff000fH
  001af	44 03 c8	 add	 r9d, eax
  001b2	49 83 eb 01	 sub	 r11, 1
  001b6	0f 85 14 ff ff
	ff		 jne	 $LL4@adler32_z

; 112  :     }
; 113  : 
; 114  :     /* do remaining bytes (less than NMAX, still just one modulo) */
; 115  :     if (len) {                  /* avoid modulos if none remaining */

  001bc	4d 85 c0	 test	 r8, r8
  001bf	0f 84 06 01 00
	00		 je	 $LN19@adler32_z

; 116  :         while (len >= 16) {

  001c5	49 83 f8 10	 cmp	 r8, 16
  001c9	0f 82 c3 00 00
	00		 jb	 $LL11@adler32_z
$LN45@adler32_z:
  001cf	49 8b d0	 mov	 rdx, r8
  001d2	48 c1 ea 04	 shr	 rdx, 4
  001d6	48 6b c2 f0	 imul	 rax, rdx, -16
  001da	4c 03 c0	 add	 r8, rax
  001dd	0f 1f 00	 npad	 3
$LL9@adler32_z:

; 117  :             len -= 16;
; 118  :             DO16(buf);

  001e0	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  001e4	03 c8		 add	 ecx, eax
  001e6	41 0f b6 42 01	 movzx	 eax, BYTE PTR [r10+1]
  001eb	44 03 c9	 add	 r9d, ecx
  001ee	03 c8		 add	 ecx, eax
  001f0	41 0f b6 42 02	 movzx	 eax, BYTE PTR [r10+2]
  001f5	44 03 c9	 add	 r9d, ecx
  001f8	03 c8		 add	 ecx, eax
  001fa	41 0f b6 42 03	 movzx	 eax, BYTE PTR [r10+3]
  001ff	44 03 c9	 add	 r9d, ecx
  00202	03 c8		 add	 ecx, eax
  00204	41 0f b6 42 04	 movzx	 eax, BYTE PTR [r10+4]
  00209	44 03 c9	 add	 r9d, ecx
  0020c	03 c8		 add	 ecx, eax
  0020e	41 0f b6 42 05	 movzx	 eax, BYTE PTR [r10+5]
  00213	44 03 c9	 add	 r9d, ecx
  00216	03 c8		 add	 ecx, eax
  00218	41 0f b6 42 06	 movzx	 eax, BYTE PTR [r10+6]
  0021d	44 03 c9	 add	 r9d, ecx
  00220	03 c8		 add	 ecx, eax
  00222	41 0f b6 42 07	 movzx	 eax, BYTE PTR [r10+7]
  00227	44 03 c9	 add	 r9d, ecx
  0022a	03 c8		 add	 ecx, eax
  0022c	41 0f b6 42 08	 movzx	 eax, BYTE PTR [r10+8]
  00231	44 03 c9	 add	 r9d, ecx
  00234	03 c8		 add	 ecx, eax
  00236	41 0f b6 42 09	 movzx	 eax, BYTE PTR [r10+9]
  0023b	44 03 c9	 add	 r9d, ecx
  0023e	03 c8		 add	 ecx, eax
  00240	41 0f b6 42 0a	 movzx	 eax, BYTE PTR [r10+10]
  00245	44 03 c9	 add	 r9d, ecx
  00248	03 c8		 add	 ecx, eax
  0024a	41 0f b6 42 0b	 movzx	 eax, BYTE PTR [r10+11]
  0024f	44 03 c9	 add	 r9d, ecx
  00252	03 c8		 add	 ecx, eax
  00254	41 0f b6 42 0c	 movzx	 eax, BYTE PTR [r10+12]
  00259	44 03 c9	 add	 r9d, ecx
  0025c	03 c8		 add	 ecx, eax
  0025e	41 0f b6 42 0d	 movzx	 eax, BYTE PTR [r10+13]
  00263	44 03 c9	 add	 r9d, ecx
  00266	03 c8		 add	 ecx, eax
  00268	41 0f b6 42 0e	 movzx	 eax, BYTE PTR [r10+14]
  0026d	44 03 c9	 add	 r9d, ecx
  00270	03 c8		 add	 ecx, eax
  00272	41 0f b6 42 0f	 movzx	 eax, BYTE PTR [r10+15]
  00277	44 03 c9	 add	 r9d, ecx

; 119  :             buf += 16;

  0027a	49 83 c2 10	 add	 r10, 16
  0027e	03 c8		 add	 ecx, eax
  00280	44 03 c9	 add	 r9d, ecx
  00283	48 83 ea 01	 sub	 rdx, 1
  00287	0f 85 53 ff ff
	ff		 jne	 $LL9@adler32_z

; 120  :         }
; 121  :         while (len--) {

  0028d	4d 85 c0	 test	 r8, r8
  00290	74 13		 je	 SHORT $LN30@adler32_z
$LL11@adler32_z:

; 122  :             adler += *buf++;

  00292	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00296	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]
  0029a	03 c8		 add	 ecx, eax

; 123  :             sum2 += adler;

  0029c	44 03 c9	 add	 r9d, ecx
  0029f	49 83 e8 01	 sub	 r8, 1
  002a3	75 ed		 jne	 SHORT $LL11@adler32_z
$LN30@adler32_z:

; 124  :         }
; 125  :         MOD(adler);

  002a5	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  002aa	f7 e1		 mul	 ecx

; 126  :         MOD(sum2);

  002ac	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  002b1	c1 ea 0f	 shr	 edx, 15
  002b4	69 d2 0f 00 ff
	ff		 imul	 edx, edx, -65521	; ffff000fH
  002ba	03 ca		 add	 ecx, edx
  002bc	41 f7 e1	 mul	 r9d
  002bf	c1 ea 0f	 shr	 edx, 15
  002c2	69 d2 0f 00 ff
	ff		 imul	 edx, edx, -65521	; ffff000fH
  002c8	44 03 ca	 add	 r9d, edx
$LN19@adler32_z:

; 127  :     }
; 128  : 
; 129  :     /* return recombined sums */
; 130  :     return adler | (sum2 << 16);

  002cb	41 c1 e1 10	 shl	 r9d, 16
  002cf	44 0b c9	 or	 r9d, ecx
  002d2	41 8b c1	 mov	 eax, r9d

; 131  : }

  002d5	c3		 ret	 0
adler32_z ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\Aegisub-WangQR\vendor\exten\zlib\adler32.c
;	COMDAT adler32
_TEXT	SEGMENT
adler$ = 8
buf$ = 16
len$ = 24
adler32	PROC						; COMDAT

; 139  :     return adler32_z(adler, buf, len);

  00000	45 8b c0	 mov	 r8d, r8d
  00003	e9 00 00 00 00	 jmp	 adler32_z
adler32	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\Aegisub-WangQR\vendor\exten\zlib\adler32.c
;	COMDAT adler32_combine_
_TEXT	SEGMENT
adler1$ = 8
adler2$ = 16
len2$ = 24
adler32_combine_ PROC					; COMDAT

; 147  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	4d 8b d0	 mov	 r10, r8
  00008	8b da		 mov	 ebx, edx
  0000a	44 8b d9	 mov	 r11d, ecx

; 148  :     unsigned long sum1;
; 149  :     unsigned long sum2;
; 150  :     unsigned rem;
; 151  : 
; 152  :     /* for negative len, return invalid adler32 as a clue for debugging */
; 153  :     if (len2 < 0)

  0000d	4d 85 c0	 test	 r8, r8
  00010	79 0b		 jns	 SHORT $LN2@adler32_co

; 154  :         return 0xffffffffUL;

  00012	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH

; 166  :     if (sum2 >= ((unsigned long)BASE << 1)) sum2 -= ((unsigned long)BASE << 1);
; 167  :     if (sum2 >= BASE) sum2 -= BASE;
; 168  :     return sum1 | (sum2 << 16);
; 169  : }

  00017	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0001c	c3		 ret	 0
$LN2@adler32_co:

; 155  : 
; 156  :     /* the derivation of this formula is left as an exercise for the reader */
; 157  :     MOD63(len2);                /* assumes len2 >= 0 */
; 158  :     rem = (unsigned)len2;
; 159  :     sum1 = adler1 & 0xffff;

  0001d	41 0f b7 cb	 movzx	 ecx, r11w
  00021	48 b8 cd c5 2f
	0d e1 00 0f 00	 mov	 rax, 4223091239536077	; 000f00e10d2fc5cdH
  0002b	49 f7 e2	 mul	 r10

; 160  :     sum2 = rem * sum1;

  0002e	44 8b c1	 mov	 r8d, ecx

; 161  :     MOD(sum2);
; 162  :     sum1 += (adler2 & 0xffff) + BASE - 1;
; 163  :     sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;

  00031	41 c1 eb 10	 shr	 r11d, 16
  00035	49 8b c2	 mov	 rax, r10
  00038	44 0f b7 cb	 movzx	 r9d, bx
  0003c	48 2b c2	 sub	 rax, rdx
  0003f	c1 eb 10	 shr	 ebx, 16
  00042	48 d1 e8	 shr	 rax, 1
  00045	44 03 c9	 add	 r9d, ecx
  00048	48 03 c2	 add	 rax, rdx

; 164  :     if (sum1 >= BASE) sum1 -= BASE;
; 165  :     if (sum1 >= BASE) sum1 -= BASE;

  0004b	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00050	48 c1 e8 0f	 shr	 rax, 15
  00054	69 c0 f1 ff 00
	00		 imul	 eax, eax, 65521		; 0000fff1H
  0005a	44 2b d0	 sub	 r10d, eax
  0005d	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00062	45 0f af c2	 imul	 r8d, r10d
  00066	41 f7 e0	 mul	 r8d
  00069	c1 ea 0f	 shr	 edx, 15
  0006c	69 c2 f1 ff 00
	00		 imul	 eax, edx, 65521		; 0000fff1H
  00072	44 2b d8	 sub	 r11d, eax
  00075	41 8d 81 f0 ff
	00 00		 lea	 eax, DWORD PTR [r9+65520]
  0007c	42 8d 14 1b	 lea	 edx, DWORD PTR [rbx+r11]

; 166  :     if (sum2 >= ((unsigned long)BASE << 1)) sum2 -= ((unsigned long)BASE << 1);
; 167  :     if (sum2 >= BASE) sum2 -= BASE;
; 168  :     return sum1 | (sum2 << 16);
; 169  : }

  00080	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00085	41 2b d2	 sub	 edx, r10d
  00088	41 ba f1 ff 00
	00		 mov	 r10d, 65521		; 0000fff1H
  0008e	41 03 d0	 add	 edx, r8d
  00091	41 b8 f0 ff 00
	00		 mov	 r8d, 65520		; 0000fff0H
  00097	41 3b c2	 cmp	 eax, r10d
  0009a	41 0f 42 c8	 cmovb	 ecx, r8d
  0009e	8d 82 f1 ff 00
	00		 lea	 eax, DWORD PTR [rdx+65521]
  000a4	3d e2 ff 01 00	 cmp	 eax, 131042		; 0001ffe2H
  000a9	46 8d 04 09	 lea	 r8d, DWORD PTR [rcx+r9]
  000ad	b9 0f 00 ff ff	 mov	 ecx, -65521		; ffff000fH
  000b2	41 0f 42 ca	 cmovb	 ecx, r10d
  000b6	03 d1		 add	 edx, ecx
  000b8	41 8d 88 0f 00
	ff ff		 lea	 ecx, DWORD PTR [r8-65521]
  000bf	41 3b d2	 cmp	 edx, r10d
  000c2	8d 82 0f 00 ff
	ff		 lea	 eax, DWORD PTR [rdx-65521]
  000c8	0f 42 c2	 cmovb	 eax, edx
  000cb	c1 e0 10	 shl	 eax, 16
  000ce	45 3b c2	 cmp	 r8d, r10d
  000d1	41 0f 42 c8	 cmovb	 ecx, r8d
  000d5	0b c1		 or	 eax, ecx
  000d7	c3		 ret	 0
adler32_combine_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File D:\Aegisub-WangQR\vendor\exten\zlib\adler32.c
;	COMDAT adler32_combine
_TEXT	SEGMENT
adler1$ = 8
adler2$ = 16
len2$ = 24
adler32_combine PROC					; COMDAT

; 177  :     return adler32_combine_(adler1, adler2, len2);

  00000	4d 63 c0	 movsxd	 r8, r8d
  00003	e9 00 00 00 00	 jmp	 adler32_combine_
adler32_combine ENDP
_TEXT	ENDS
END
